# for Loop

<br />

Vòng lặp **`for`** được sử dụng để duyệt qua các phần tử trong một tập hợp. Nó thường được sử dụng khi bạn có một khối câu lệnh cần được thực thi `n` lần, có nghĩa là bạn biết được số lượng vòng lặp cần thực hiện.

<br />

## I. The syntax of the `for` loop

<br />

```c
for (khởi tạo giá trị biến lặp; điều kiện lặp; cập nhật biến lặp) {

   // statements inside the body of loop
}
```

<br />

## II. How `for` loop works?

<p align="center">
  <img src="https://github.com/AnestLearning/Course-C-Fundamentals/blob/master/Images/for-loop-structure.jpg">
</p>

- Bước 1: Khởi tạo giá trị biến lặp, chỉ thực hiện 1 lần duy nhất
- Bước 2: Kiểm tra điều kiện lặp, nếu điều kiện **`false`** thì kết thúc vòng lặp.
- Bước 3: Tuy nhiên, nếu biểu thức kiểm tra là **`true`**, các câu lệnh bên trong phần thân của vòng lặp **`for`** được thực thi.
- Bước 4: Cập nhật giá trị biến lặp và quay trở lại bước 2 để kiểm tra.

Quá trình này diễn ra cho đến khi biểu thức điều kiện (bước 2) kiểm tra là **`false`**. Khi biểu thức điều kiện kiểm tra là **`false`**, vòng lặp chấm dứt.

<br />

## III. `for` loop flowchart

<br />

<p align="center">
  <img src="https://github.com/AnestLearning/Course-C-Fundamentals/blob/master/Images/c-for-loop.jpg">
</p>

<br />

## IV. Example:

### 1. Ví dụ in ra các số từ 1 đến 10.
```c
#include <stdio.h>
 
int main() {

    for (int i = 1; i <= 10; i++) {
        printf("%d\n", i);
    }

    printf("End loop!\n");
}
```

Kết quả:
```c
1
2
3
4
5
6
7
8
9
10
End loop!
```

Giải thích:
- Bước 1. Gán biến lặp `i = 1` - thực hiện 1 lần duy nhất
- Bước 2. Kiểm tra điều kiện `(i = 1) < 10` → `true`
- Bước 3. Do kiểm tra điều kiện `true` → Thực hiện thân vòng lặp `for` → in ra giá trị của `i`
- Bước 4. Gọi tới `i++` → tăng `i` lên `1` đơn vị → lúc này `i = 2`
- Bước 5. Quay lại bước 2 và chạy lại
- Chúng ta sẽ lặp đi lặp lại bước 2 đến bước 5 cho đến khi `i = 11`, lúc này bước 2 sẽ trả về `false` → Kết thúc luôn vòng lặp.

<br />

### 2. Ví dụ in ra các số chẵn từ 1 đến 10.
```c
#include <stdio.h>
 
int main() {

    for (int i = 1; i <= 10; i++) {
        if (i % 2 == 0) {
            printf("%d\n", i);
        }
    }

    printf("End loop!\n");
}
```

Kết quả:
```c
2
4
6
8
10
End loop!
```


<br />

### 3. Ví dụ cộng tổng các số từ 1 đến 10.
```c
#include <stdio.h>
 
int main() {

    int sum = 0;
    for (int i = 1; i <= 10; i++) {
        sum += i;
    }
    
    printf("sum = %d\n", sum);
    printf("End loop!\n");
}
```
Nếu bạn không nhớ `sum += i;` là gì? Bạn có thể xem lại bài viết về toán tử Assignment Operators [tại đây](https://github.com/AnestLearning/Course-C-Fundamentals/blob/master/2.%20Basic%20Concepts/5.%20Operators.md).

Kết quả:
```c
sum = 55
End loop!
```

<br />

### 4. Kiểm tra số `n` có phải số nguyên tố hay không.

Đây là một ví dụ phức tạp hơn và cần nhiều sự tư duy hơn, kết hợp nhiều thứ đã học lại từ trước đến này:

- Thư viện `math.h`
- `if`
- `for`

<br />

**1. Khái niệm số nguyên tố**

> Số nguyên tố là số nguyên dương có duy nhất 2 ước phân biệt là `1` và chính nó. _Lưu ý: Số 1 không phải số nguyên tố do chỉ có 1 ước._

<br />

**2. Ý tưởng kiểm tra số nguyên tố**

- Nếu `n < 2`, kết luận `n` không phải số nguyên tố. Sử dụng `if` để kiểm tra `n`.
- Đếm số ước của `n` trong đoạn từ `2` đến căn bậc hai của `n` (sử dụng `for`). Nếu `n` không có ước nào trong đoạn từ `2` đến căn bậc hai của `n` thì nó là số nguyên tố (sử dụng `if` để kiểm tra). Ngược lại thì không phải.

<br />

**3. Tại sao lại chỉ đếm các ước trong đoạn từ `2` đến căn của `n`?**

Nếu bạn để ý thì một số nguyên `>= 2` bất kỳ sẽ luôn có số ước ở nửa đầu căn bậc 2 của nó bằng số ước ở nửa sau căn bậc 2 của nó. Cụ thể, các ước sẽ phân bố thành 2 miền từ `2 → sqrt(x)` và từ `sqrt(x) → x`.

Phân tích cụ thể:
> Với số **12**, ta có `sqrt(12) ≈ 3.464`  
> Đoạn [ 2 → 3.464 ] có ước bằng 2, tương ứng đoạn [ 3.464 → 12 ] có ước bằng 6  
> Đoạn [ 2 → 3.464 ] có ước bằng 3, tương ứng đoạn [ 3.464 → 12 ] có ước bằng 4  
> Trong đoạn [ 2 → 3.464 ] số **12** chia hết cho 2 số [ 2, 3 ] → **12** không phải là số nguyên tố.
 
> Với số **9**, ta có `sqrt(9) = 3`  
> Đoạn [ 2 → 3 ] có ước 3, tương ứng đoạn [ 3 → 9 ] có ước 3  
> Trong đoạn [ 2 → 3 ] số **9** chia hết cho 1 số [ 3 ] → **9** không phải là số nguyên tố.

> Với số **7**, ta có `sqrt(7) ≈ 2.646`  
> Trong đoạn từ [ 2 → 2.646 ] không có số nguyên nào mà **7** chia hết → **7** là số nguyên tố.

<br />

**4. Triển khai code**

```c
 1    #include <stdio.h>
 2    #include <math.h>
 3     
 4    int main() {
 5    
 6        int n;
 7       
 8        printf("Enter n: ");
 9        scanf("%d", &n);
10        
11        if (n < 2) {
12            printf("n is not a prime number.\n");
13            return 0;
14        }  
15        
16        int check = 1;
17        for (int i = 2; i <= sqrt(n); i++) {
18            if (n % i == 0) {
19                printf("n is not a prime number.\n");
20                check = 0;
21                break;
22            }
23        }
24        
25        if (check) {
26            printf("n a prime number.\n");
27        }  		
28    }
```

Kết quả khi chạy chương trình:
```c
Enter n: 1
n is not a prime number.
```
```c
Enter n: 11
n a prime number.
```
```c
Enter n: 12
n is not a prime number.
```

<br />

**`return`** - đây là từ khoá dùng để kết thúc một hàm xử lý, khi gặp từ khoá **`return`** thì chương trình sẽ không chạy tiếp các dòng mã bên dưới từ **`return`** nữa. Trong ví dụ trên, khi nhập `n < 2` thì chương trình sẽ chạy vào câu lệnh `if` (line 11) và thực hiện lệnh `return 0;` (line 13) - lúc này **chương trình sẽ kết thúc** và những dòng mã từ line 15 → line 27 sẽ **không** được thực hiện.

**`break`** - đầy là một từ khoá hay dùng đi với vòng lặp, để hiểu rõ về nó bạn hãy đọc bài viết tiếp theo [tại đây](https://github.com/AnestLearning/Course-C-Fundamentals/blob/master/4.%20Loops/4.%20break%20%26%20continue.md).


##  

© Copyright
> ANEST LEARNING  
> Join us: [Facebook groups](https://www.facebook.com/groups/anest.learning/)
